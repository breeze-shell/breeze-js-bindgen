import log from 'fancy-log';
import { ClangASTD } from "./clang-ast";
import { existsSync, readFileSync, rmSync, writeFileSync, mkdirSync } from "node:fs";
import { join, dirname, resolve as resolvePath } from "node:path";
import { fileURLToPath } from "node:url";
import { spawnSync } from "node:child_process";
import { CTypeParser, cTypeToTypeScript } from "./c-type-parser";

const DEFAULT_CPP_BINDING_OUTPUT_FILE = 'binding_qjs.h';
const DEFAULT_TS_DEFINITION_OUTPUT_FILE = 'binding_types.d.ts';
const DEFAULT_AST_JSON_TEMP_FILE = 'ast.temp.json';
const DEFAULT_QUICKJS_TYPES_PATH = 'quickjs-types.txt'; // Relative to bindgen directory
const DEFAULT_NAME_FILTER = "breeze::js::";


interface GenerationResult {
    cppBinding: string;
    tsDefinitions: string;
}

interface BindgenConfig {
    cppFilePath: string;
    outputDir: string;
    clangPath?: string;
    cppBindingOutputFile?: string;
    tsDefinitionOutputFile?: string;
    quickjsTypesPath?: string;
    nameFilter?: string;
}

function parseFunctionQualType(type: string): { returnType: string; args: string[] } {
    enum State { ReturnType, Args, Done }
    let state = State.ReturnType;
    let returnType = '';
    let currentArg = '';
    let args: string[] = [];
    let depth = 0;
    let angleBracketDepth = 0;

    for (let i = 0; i < type.length; i++) {
        const char = type[i];
        if (char === '<') angleBracketDepth++;
        else if (char === '>') angleBracketDepth--;

        switch (state) {
            case State.ReturnType:
                if (char === '(' && angleBracketDepth === 0) {
                    state = State.Args;
                    returnType = returnType.trim();
                } else {
                    returnType += char;
                }
                break;
            case State.Args:
                if (char === '(') depth++;
                if (char === ')') {
                    if (depth === 0 && angleBracketDepth === 0) {
                        if (currentArg.trim()) args.push(currentArg.trim());
                        state = State.Done;
                        break;
                    }
                    depth--;
                }
                if (char === ',' && depth === 0 && angleBracketDepth === 0) {
                    args.push(currentArg.trim());
                    currentArg = '';
                } else {
                    currentArg += char;
                }
                break;
        }
    }
    if (state !== State.Done) throw new Error('Invalid function type');
    return { returnType, args };
}

function processAstAndGenerateCode(
    astArr: ClangASTD[],
    originalCppFilePath: string,
    bindgenDir: string, // Directory where bindgen scripts (like quickjs-types.txt) are located
    nameFilter: string, // Pass nameFilter here
    quickjsTypesPath: string // Pass quickjsTypesPath here
): GenerationResult {
    const origFileContent = readFileSync(originalCppFilePath, 'utf-8').split('\n').map(v => v.trim());
    const structNames: string[] = [];

    const resolveUnderPath = (path: string[], resolveName: string): string => {
        const ns = path.join('::');
        const fullName = `${ns}::${resolveName}`;
        if (structNames.includes(fullName)) return fullName;
        if (path.length > 1) {
            const parentPath = path.slice(0, -1);
            const parentFullName = resolveUnderPath(parentPath, resolveName);
            if (parentFullName) return parentFullName;
        }
        return resolveName;
    };

    const ctypeToQualified = (type: string, path: string[]): string => {
        const parser = new CTypeParser();
        const parsed = parser.parse(type, name => resolveUnderPath(path, name));
        return parser.formatToC(parsed);
    };

    let binding = `// This file is generated by bindgen
// Do not modify this file manually!

#pragma once
#include "binding_types.h" // Assuming this will be in the same output directory
#include "quickjs.h"
#include "quickjspp.hpp"

template <typename T>
struct js_bind {
    static void bind(qjs::Context::Module &mod) {}
};
`;

    let typescriptDef = `// This file is generated by bindgen
// Do not modify this file manually!

declare module 'mshell' { // TODO: Make module name configurable or derive
`;

    const generateForRecordDecl = (node_struct: ClangASTD, path: string[]) => {
        if (node_struct.kind !== 'CXXRecordDecl') throw new Error('Node is not a RecordDecl');
        const structName = node_struct.name!;
        const fields: { name: string; type: string; comment?: string }[] = [];
        const methods: { name: string; returnType: string; args: string[]; static: boolean; comment?: string; argNames?: string[] }[] = [];
        const bases: { access: 'public' | 'protected' | 'private'; type: string }[] = node_struct.bases?.filter(base => !base.type.qualType.includes('std::'))
            .map(base => ({
                access: base.access as any,
                type: ctypeToQualified(base.type!.qualType, path)
            })) || [];

        if (!node_struct.inner) return;

        for (const node of node_struct.inner) {
            if (node.name?.startsWith('$')) continue;
            const lineNum = node.loc?.line;
            let comment = '';
            if (lineNum) {
                let rangeCommentCnt = 0;
                for (let i = lineNum - 2; i >= 0; i--) {
                    const line = origFileContent[i];
                    if (!line) continue;
                    if (line.startsWith('//')) {
                        comment = line.substring(2) + '\n' + comment;
                        continue;
                    }
                    if (line.startsWith('/*')) rangeCommentCnt++;
                    if (line.endsWith('*/')) rangeCommentCnt--;
                    if (rangeCommentCnt === 0 && (line.startsWith('/*') || line.endsWith('*/'))) {
                         if (line.startsWith('/*') && line.endsWith('*/')) {
                            comment = line.substring(2, line.length - 2) + '\n' + comment;
                         } else if (line.startsWith('/*')) {
                            // part of multi-line comment, continue
                         } else if (line.endsWith('*/')) {
                            comment = line.substring(0, line.length - 2) + '\n' + comment;
                         }
                         break; // End of single or multi-line comment block
                    } else if (rangeCommentCnt > 0 || line.endsWith('*/')) {
                         comment = line.replaceAll('/*', '').replaceAll('*/', '*') + '\n' + comment;
                    } else if (rangeCommentCnt === 0 && !line.startsWith('//') && !line.startsWith('/*') && !line.endsWith('*/')) {
                        break; // Not a comment line
                    }
                }
            }
            comment = comment.trim();


            if (node.kind === 'FieldDecl') {
                fields.push({
                    name: node.name!,
                    type: ctypeToQualified(node.type!.qualType, path),
                    comment: comment.length > 0 ? comment : undefined
                });
            }

            if (node.kind === 'CXXMethodDecl') {
                const parsed = parseFunctionQualType(node.type!.qualType);
                if (['operator='].includes(node.name!)) continue;
                const argNames: string[] = [];
                if (node.inner) {
                    for (const arg of node.inner) {
                        if (arg.kind === 'ParmVarDecl') argNames.push(arg.name!);
                    }
                }
                methods.push({
                    name: node.name!,
                    returnType: ctypeToQualified(parsed.returnType, path),
                    args: parsed.args.map(arg => ctypeToQualified(arg, path)),
                    static: node.storageClass === 'static',
                    comment: comment.length > 0 ? comment : undefined,
                    argNames
                });
            }
        }

        const fullName = path.join('::') + '::' + structName;
        if (bases.length === 0) {
            binding += `
template <> struct qjs::js_traits<${fullName}> {
    static ${fullName} unwrap(JSContext *ctx, JSValueConst v) {
        ${fullName} obj;
`;
            for (const field of fields) {
                binding += `
        obj.${field.name} = js_traits<${field.type}>::unwrap(ctx, JS_GetPropertyStr(ctx, v, "${field.name}"));
`;
            }
            binding += `
        return obj;
    }

    static JSValue wrap(JSContext *ctx, const ${fullName} &val) noexcept {
        JSValue obj = JS_NewObject(ctx);
`;
            for (const field of fields) {
                binding += `
        JS_SetPropertyStr(ctx, obj, "${field.name}", js_traits<${field.type}>::wrap(ctx, val.${field.name}));
`;
            }
            binding += `
        return obj;
    }
};`;
        }

        const jsNamespaceName = fullName.replace(nameFilter, '');

        binding += `
template<> struct js_bind<${fullName}> {
    static void bind(qjs::Context::Module &mod) {
        mod.class_<${fullName}>("${jsNamespaceName}")
            .constructor<>()`;
        if (bases.length > 0) {
            binding += `
                .base<${bases[0].type}>()`;
        }
        for (const method of methods) {
            binding += `
                .${method.static ? 'static_' : ''}fun<&${fullName}::${method.name}>("${method.name}")`;
        }
        for (const field of fields) { // Assuming fields are exposed as getter/setter methods or properties
            binding += `
                .property<&${fullName}::${field.name}>("${field.name}")`; // Or .fun if it's a method
        }
        binding += `
            ;
    }
};
`;

        const tsNamespaceParts = jsNamespaceName.split("::");
        const tsClassName = tsNamespaceParts.pop() || structName;
        const tsNamespace = tsNamespaceParts.join('.');

        if (tsNamespace) typescriptDef += `\nnamespace ${tsNamespace} {`;
        typescriptDef += `
export class ${tsClassName}${bases.length > 0 ? ` extends ${bases.map(base => base.type.split('::').pop() ?? base.type).join(', ')}` : ''} {`;
        fields.forEach(field => {
            let fieldDef = `${field.name}${field.type.startsWith('std::optional') ? '?' : ''}: ${cTypeToTypeScript(field.type, nameFilter)}`; // Use parameter
            if (field.comment) {
                fieldDef = `
    /**
     * ${field.comment.split('\n').join('\n     * ')}
     */
    ${fieldDef}`;
            }
            typescriptDef += `\n\t${fieldDef.trim()}`;
        });
        methods.forEach(method => {
            let methodDef = `${method.static ? 'static ' : ''}${method.name}(${method.argNames && method.argNames.length > 0 ? method.args.map((arg, i) => `${method.argNames![i] || `arg${i}`}: ${cTypeToTypeScript(arg, nameFilter)}`).join(', ') : ''}): ${cTypeToTypeScript(method.returnType, nameFilter)}`; // Use parameter
            let comments = '';
            if (method.comment) comments += method.comment;
            if (comments || (method.argNames && method.argNames.length > 0)) {
                 methodDef = `
    /**
     * ${comments.split('\n').join('\n     * ')}
     ${method.argNames && method.argNames.length > 0 ? `* @param ${method.args.map((arg, i) => `${method.argNames![i] || `arg${i}`}${cTypeToTypeScript(arg, nameFilter) === 'any' ? '' : `: ${cTypeToTypeScript(arg, nameFilter)}`}`).join('\n     * @param ')}\n     *` : ''} @returns ${cTypeToTypeScript(method.returnType, nameFilter)}
     */
    ${methodDef}`;
            }
            typescriptDef += `\n\t${methodDef.trim()}`;
        });
        typescriptDef += `\n}`;
        if (tsNamespace) typescriptDef += `\n}`;
    };

    const enumerateStructDecls = (node: ClangASTD, callback: (node: ClangASTD, path: string[]) => void, path: string[] = ['breeze']) => { // Assuming 'breeze' as a root, might need adjustment
        if (node.kind === 'CXXRecordDecl' && node.name && node.inner) {
             // Only consider nodes that are part of the main file, not includes, if loc.file is available and matches.
            // This check needs to be robust. For now, we assume the AST dump filter handles this.
            callback(node, path);
        }
        if (node.inner) {
            for (const child of node.inner) {
                enumerateStructDecls(child, callback, [...path, node.name || '']);
            }
        }
    };

    for (const ast of astArr) {
        enumerateStructDecls(ast, (node, path) => {
            if (node.name) structNames.push(path.join('::') + '::' + node.name);
        });
    }
    for (const ast of astArr) {
        enumerateStructDecls(ast, (node, path) => {
            if (node.kind === 'CXXRecordDecl' && node.name) generateForRecordDecl(node, path);
        });
    }

    binding += `
inline void bindAll(qjs::Context::Module &mod) {
`;
    for (const structName of structNames) {
        binding += `
    js_bind<${structName}>::bind(mod);
`;
    }
    binding += `
}
`;
    typescriptDef += `\n}\n`; // Close 'mshell' module

    // Append quickjs-types.txt content
    const quickjsTypesContent = readFileSync(join(bindgenDir, quickjsTypesPath), 'utf-8'); // Use parameter
    typescriptDef += '\n' + quickjsTypesContent;


    return { cppBinding: binding, tsDefinitions: typescriptDef };
}

export function generateBindingsAndDefinitions(config: BindgenConfig): void {
    const {
        cppFilePath,
        outputDir,
        clangPath = 'clang++',
        cppBindingOutputFile = DEFAULT_CPP_BINDING_OUTPUT_FILE,
        tsDefinitionOutputFile = DEFAULT_TS_DEFINITION_OUTPUT_FILE,
        quickjsTypesPath = DEFAULT_QUICKJS_TYPES_PATH,
        nameFilter = DEFAULT_NAME_FILTER
    } = config;

    const absoluteCppFilePath = resolvePath(cppFilePath);
    const absoluteOutputDir = resolvePath(outputDir);
    // @ts-ignore - import.meta.url is standard in ES modules
    const currentFilePath = fileURLToPath(import.meta.url);
    const bindgenDir = dirname(currentFilePath);
    // const astJsonOutPath = join(bindgenDir, astJsonTempFile); // Removed temporary file

    const clangArgs = [
        '-Xclang', '-ast-dump=json',
        '-fsyntax-only',
        '-Xclang', `-ast-dump-filter=${nameFilter.slice(0, -2)}`, // Use parameter
        '-std=c++2c', // or c++20, c++17 as appropriate
        // Add any include paths if necessary, e.g. -I../../include
        absoluteCppFilePath
    ];

    log(`Executing: ${clangPath} ${clangArgs.join(' ')}`); // Removed redirection

    const clangProcess = spawnSync(clangPath, clangArgs, { encoding: 'utf-8', shell: true });

    if (clangProcess.error) {
        log.error(`Failed to start clang++: ${clangProcess.error.message}`);
        if ((clangProcess.error as any).code === 'ENOENT') {
            throw new Error(`clang++ not found at path "${clangPath}". Please ensure it's installed and in your PATH, or provide a correct path.`);
        }
        throw clangProcess.error;
    }
    
    // Clang AST dump often outputs to stdout. Read directly from stdout.
    if (clangProcess.stderr && clangProcess.stderr.length > 0) {
        log.warn(`clang++ stderr:\n${clangProcess.stderr}`);
    }
    if (!clangProcess.stdout || clangProcess.stdout.trim().length === 0) {
         throw new Error(`clang++ produced no output (stdout). AST generation failed. Error: ${clangProcess.stderr}`);
    }

    // The output from clang++ -ast-dump=json is a series of JSON objects, not a single JSON array.
    // It needs to be wrapped in [] and commas inserted.
    let astText = clangProcess.stdout;
    if (!astText.trim().startsWith('[')) { // Check if it's already an array (unlikely for raw dump)
        astText = '[' + astText.trim().replace(/}\s*{/g, '},{') + ']';
    }
    
    // No temporary file is created, so no writing to file here.

    let astArr: ClangASTD[];
    try {
        astArr = JSON.parse(astText) as ClangASTD[];
    } catch (e) {
        log.error("Failed to parse AST JSON:", e);
        log.error("Problematic AST JSON content (first 1000 chars):", astText.substring(0, 1000));
        // Removed reference to temporary file in error message
        throw new Error(`Failed to parse AST JSON from clang++. Check for errors in C++ code or clang++ execution.`);
    }

    if (!astArr || astArr.length === 0) {
        log.warn(`No AST data was parsed. This might mean the ast-dump-filter ("${nameFilter.slice(0,-2)}") didn't match anything, or the input file is empty or has no relevant declarations.`); // Use parameter
        // Decide if this is an error or just an empty generation case
    }


    const { cppBinding, tsDefinitions } = processAstAndGenerateCode(astArr, absoluteCppFilePath, bindgenDir, nameFilter, quickjsTypesPath); // Pass nameFilter and quickjsTypesPath

    if (!existsSync(absoluteOutputDir)) {
        // fs.mkdirSync(absoluteOutputDir, { recursive: true }); // Node 10.12+
        // For broader compatibility, create simple dir, ensure parent exists or handle error
        try {
            mkdirSync(absoluteOutputDir, { recursive: true });
        } catch (e: any) {
            throw new Error(`Failed to create output directory ${absoluteOutputDir}: ${e.message}`);
        }
    }

    writeFileSync(join(absoluteOutputDir, cppBindingOutputFile), cppBinding); // Use parameter
    writeFileSync(join(absoluteOutputDir, tsDefinitionOutputFile), tsDefinitions); // Use parameter

    log(`Bindings generated successfully in ${absoluteOutputDir}`);

    // No temporary file is created, so no cleanup needed
}