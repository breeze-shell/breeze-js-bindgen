import log from 'fancy-log';
import { ClangASTD } from "./clang-ast";
import { existsSync, readFileSync, rmSync, writeFileSync, mkdirSync } from "node:fs";
import { join, dirname, resolve as resolvePath } from "node:path";
import { fileURLToPath } from "node:url";
import { spawnSync } from "node:child_process";
import { CTypeParser, cTypeToTypeScript } from "./c-type-parser";

const DEFAULT_CPP_BINDING_OUTPUT_FILE = 'binding_qjs.h';
const DEFAULT_TS_DEFINITION_OUTPUT_FILE = 'binding_types.d.ts';
const DEFAULT_NAME_FILTER = "breeze::js::";
const RETRIEVE_COMMENTS_USING_AST = true;

interface GenerationResult {
    cppBinding: string;
    tsDefinitions: string;
}

interface BindgenConfig {
    cppFilePath: string;
    outputDir: string;
    clangPath?: string;
    cppBindingOutputFile?: string;
    tsDefinitionOutputFile?: string;
    additionalTypes?: string;
    tsModuleName?: string;
    nameFilter?: string;
}

function parseFunctionQualType(type: string): { returnType: string; args: string[] } {
    enum State { ReturnType, Args, Done }
    let state = State.ReturnType;
    let returnType = '';
    let currentArg = '';
    let args: string[] = [];
    let depth = 0;
    let angleBracketDepth = 0;

    for (let i = 0; i < type.length; i++) {
        const char = type[i];
        if (char === '<') angleBracketDepth++;
        else if (char === '>') angleBracketDepth--;

        switch (state) {
            case State.ReturnType:
                if (char === '(' && angleBracketDepth === 0) {
                    state = State.Args;
                    returnType = returnType.trim();
                } else {
                    returnType += char;
                }
                break;
            case State.Args:
                if (char === '(') depth++;
                if (char === ')') {
                    if (depth === 0 && angleBracketDepth === 0) {
                        if (currentArg.trim()) args.push(currentArg.trim());
                        state = State.Done;
                        break;
                    }
                    depth--;
                }
                if (char === ',' && depth === 0 && angleBracketDepth === 0) {
                    args.push(currentArg.trim());
                    currentArg = '';
                } else {
                    currentArg += char;
                }
                break;
        }
    }
    if (state !== State.Done) throw new Error('Invalid function type');
    return { returnType, args };
}

function processAstAndGenerateCode(
    astArr: ClangASTD[],
    originalCppFilePath: string,
    nameFilter: string,
    additionalTypes: string,
    tsModuleName: string
): GenerationResult {
    const origFileContent = readFileSync(originalCppFilePath, 'utf-8').split('\n').map(v => v.trim());
    const structNames: string[] = [];

    const resolveUnderPath = (path: string[], resolveName: string): string => {
        const ns = path.join('::');
        const fullName = `${ns}::${resolveName}`;
        if (structNames.includes(fullName)) return fullName;
        if (path.length > 1) {
            const parentPath = path.slice(0, -1);
            const parentFullName = resolveUnderPath(parentPath, resolveName);
            if (parentFullName) return parentFullName;
        }
        return resolveName;
    };

    const ctypeToQualified = (type: string, path: string[]): string => {
        const parser = new CTypeParser();
        const parsed = parser.parse(type, name => resolveUnderPath(path, name));
        return parser.formatToC(parsed);
    };

    let binding = `// This file is generated by Breeze.JS Bindgen (https://github.com/breeze-shell/breeze-js-bindgen)
// Do not modify this file manually!

#pragma once
#include "binding_types.h"
#include "quickjs.h"
#include "quickjspp.hpp"

template <typename T>
struct js_bind {
    static void bind(qjs::Context::Module &mod) {}
};
`;

    let typescriptDef = `// This file is generated by bindgen
// Do not modify this file manually!

declare module '${tsModuleName}' {
`;

    const generateForRecordDecl = (node_struct: ClangASTD, path: string[]) => {
        if (node_struct.kind !== 'CXXRecordDecl') throw new Error('Node is not a RecordDecl');
        const structName = node_struct.name!;
        const fields: { name: string; type: string; comment?: string }[] = [];
        const methods: { name: string; returnType: string; args: string[]; static: boolean; comment?: string; argNames?: string[] }[] = [];
        const bases: { access: 'public' | 'protected' | 'private'; type: string }[] = node_struct.bases?.filter(base => !base.type.qualType.includes('std::'))
            .map(base => ({
                access: base.access as any,
                type: ctypeToQualified(base.type!.qualType, path)
            })) || [];

        if (!node_struct.inner) return;

        for (const node of node_struct.inner) {
            if (node.name?.startsWith('$')) continue;
            const lineNum = node.loc?.line;

            let comment = '';
            if (RETRIEVE_COMMENTS_USING_AST) {
                const dfsForComment = (node: ClangASTD): string => {
                    if (node.kind === 'TextComment') {
                        return node.text || '';
                    }
                    if (node.inner) {
                        return node.inner.map(dfsForComment).filter(Boolean).join('\n');
                    }
                    return '';
                }
                comment = dfsForComment(node);
            } else {
                if (lineNum) {
                    let rangeCommentCnt = 0;
                    for (let i = lineNum - 2; i >= 0; i--) {
                        const line = origFileContent[i];
                        if (!line) continue;
                        if (line.startsWith('//')) {
                            comment = line.substring(2) + '\n' + comment;
                            continue;
                        }
                        if (line.startsWith('/*')) rangeCommentCnt++;
                        if (line.endsWith('*/')) rangeCommentCnt--;
                        if (rangeCommentCnt === 0 && (line.startsWith('/*') || line.endsWith('*/'))) {
                            if (line.startsWith('/*') && line.endsWith('*/')) {
                                comment = line.substring(2, line.length - 2) + '\n' + comment;
                            } else if (line.startsWith('/*')) {
                            } else if (line.endsWith('*/')) {
                                comment = line.substring(0, line.length - 2) + '\n' + comment;
                            }
                            break;
                        } else if (rangeCommentCnt > 0 || line.endsWith('*/')) {
                            comment = line.replaceAll('/*', '').replaceAll('*/', '*') + '\n' + comment;
                        } else if (rangeCommentCnt === 0 && !line.startsWith('//') && !line.startsWith('/*') && !line.endsWith('*/')) {
                            break;
                        }
                    }
                }
                comment = comment.trim();
            }


            if (node.kind === 'FieldDecl') {
                fields.push({
                    name: node.name!,
                    type: ctypeToQualified(node.type!.qualType, path),
                    comment: comment.length > 0 ? comment : undefined
                });
            }

            if (node.kind === 'CXXMethodDecl') {
                const parsed = parseFunctionQualType(node.type!.qualType);
                if (['operator='].includes(node.name!)) continue;
                const argNames: string[] = [];
                if (node.inner) {
                    for (const arg of node.inner) {
                        if (arg.kind === 'ParmVarDecl') argNames.push(arg.name!);
                    }
                }

                methods.push({
                    name: node.name!,
                    returnType: ctypeToQualified(parsed.returnType, [...path, node.name!]),
                    args: parsed.args.map(arg => ctypeToQualified(arg, [...path, node_struct.name!])),
                    static: node.storageClass === 'static',
                    comment: comment.length > 0 ? comment : undefined,
                    argNames
                });
            }
        }

        const fullName = path.join('::') + '::' + structName;
        if (bases.length === 0) {
            binding += `
template <> struct qjs::js_traits<${fullName}> {
    static ${fullName} unwrap(JSContext *ctx, JSValueConst v) {
        ${fullName} obj;
`;
            for (const field of fields) {
                binding += `
        obj.${field.name} = js_traits<${field.type}>::unwrap(ctx, JS_GetPropertyStr(ctx, v, "${field.name}"));
`;
            }
            binding += `
        return obj;
    }

    static JSValue wrap(JSContext *ctx, const ${fullName} &val) noexcept {
        JSValue obj = JS_NewObject(ctx);
`;
            for (const field of fields) {
                binding += `
        JS_SetPropertyStr(ctx, obj, "${field.name}", js_traits<${field.type}>::wrap(ctx, val.${field.name}));
`;
            }
            binding += `
        return obj;
    }
};`;
        }

        const jsNamespaceName = fullName.replace(nameFilter, '');

        binding += `
template<> struct js_bind<${fullName}> {
    static void bind(qjs::Context::Module &mod) {
        mod.class_<${fullName}>("${jsNamespaceName}")
            .constructor<>()`;
        if (bases.length > 0) {
            binding += `
                .base<${bases[0].type}>()`;
        }
        for (const method of methods) {
            binding += `
                .${method.static ? 'static_' : ''}fun<&${fullName}::${method.name}>("${method.name}")`;
        }
        for (const field of fields) {
            binding += `
                .fun<&${fullName}::${field.name}>("${field.name}")`;
        }
        binding += `
            ;
    }
};
`;

        const tsNamespaceParts = jsNamespaceName.split("::");
        const tsClassName = tsNamespaceParts.pop() || structName;
        const tsNamespace = tsNamespaceParts.join('.');

        if (tsNamespace) typescriptDef += `\nnamespace ${tsNamespace} {`;
        typescriptDef += `
export class ${tsClassName}${bases.length > 0 ? ` extends ${bases.map(base => base.type.split('::').pop() ?? base.type).join(', ')}` : ''} {`;
        fields.forEach(field => {
            let fieldDef = `${field.name}${field.type.startsWith('std::optional') ? '?' : ''}: ${cTypeToTypeScript(field.type, nameFilter)}`;
            if (field.comment) {
                fieldDef = `
    /**
     * ${field.comment.split('\n').join('\n     * ')}
     */
    ${fieldDef}`;
            }
            typescriptDef += `\n\t${fieldDef.trim()}`;
        });
        methods.forEach(method => {
            let methodDef = `${method.static ? 'static ' : ''}${method.name}(${method.argNames && method.argNames.length > 0 ? method.args.map((arg, i) =>
                `${method.argNames![i] || `arg${i}`}${arg.startsWith('std::optional') ? '?' : ''
                }: ${cTypeToTypeScript(arg, nameFilter)}`).join(', ') : ''}): ${cTypeToTypeScript(method.returnType, nameFilter)}`;
            let comments = '';
            if (method.comment) comments += method.comment;
            if (comments || (method.argNames && method.argNames.length > 0)) {
                methodDef = `
    /**
     * ${comments.split('\n').join('\n     * ')}
     ${method.argNames && method.argNames.length > 0 ? `* @param ${method.args.map((arg, i) => `${method.argNames![i] || `arg${i}`}${cTypeToTypeScript(arg, nameFilter) === 'any' ? '' : `: ${cTypeToTypeScript(arg, nameFilter)}`}`).join('\n     * @param ')}\n     *` : ''} @returns ${cTypeToTypeScript(method.returnType, nameFilter)}
     */
    ${methodDef}`;
            }
            typescriptDef += `\n\t${methodDef.trim()}`;
        });
        typescriptDef += `\n}`;
        if (tsNamespace) typescriptDef += `\n}`;
    };

    const enumerateStructDecls = (node: ClangASTD, callback: (node: ClangASTD, path: string[]) => void, path: string[] = [nameFilter.split('::')[0]]) => {
        if (node.kind === 'CXXRecordDecl' && node.name && node.inner) {
            callback(node, path);
        }
        if (node.inner) {
            for (const child of node.inner) {
                enumerateStructDecls(child, callback, [...path, node.name || '']);
            }
        }
    };

    for (const ast of astArr) {
        enumerateStructDecls(ast, (node, path) => {
            if (node.name) structNames.push(path.join('::') + '::' + node.name);
        });

    }
    for (const ast of astArr) {
        enumerateStructDecls(ast, (node, path) => {
            if (node.kind === 'CXXRecordDecl' && node.name) generateForRecordDecl(node, path);
        });
    }

    binding += `
inline void bindAll(qjs::Context::Module &mod) {
`;
    for (const structName of structNames) {
        binding += `
    js_bind<${structName}>::bind(mod);
`;
    }
    binding += `
}
`;
    typescriptDef += `\n}\n`;

    typescriptDef += '\n' + additionalTypes;


    return { cppBinding: binding, tsDefinitions: typescriptDef };
}

export function generateBindingsAndDefinitions(config: BindgenConfig): void {
    const {
        cppFilePath,
        outputDir,
        clangPath = 'clang++',
        cppBindingOutputFile = DEFAULT_CPP_BINDING_OUTPUT_FILE,
        tsDefinitionOutputFile = DEFAULT_TS_DEFINITION_OUTPUT_FILE,
        additionalTypes = '',
        nameFilter = DEFAULT_NAME_FILTER,
        tsModuleName = 'mshell'
    } = config;

    const absoluteCppFilePath = resolvePath(cppFilePath);
    const absoluteOutputDir = resolvePath(outputDir);

    const clangArgs = [
        '-Xclang', '-ast-dump=json',
        '-Xclang', `-ast-dump-filter=${nameFilter.slice(0, -2)}`,
        '-std=c++2c', '-fsyntax-only', '-fparse-all-comments',
        absoluteCppFilePath
    ];

    log(`Executing: ${clangPath} ${clangArgs.join(' ')}`);

    const clangProcess = spawnSync(clangPath, clangArgs, { encoding: 'utf-8', maxBuffer: 200 * 1024 * 1024 });

    if (clangProcess.error) {
        log.error(`Failed to start clang++: ${clangProcess.error.message}`);
        if ((clangProcess.error as any).code === 'ENOENT') {
            throw new Error(`clang++ not found at path "${clangPath}". Please ensure it's installed and in your PATH, or provide a correct path.`);
        }
        throw clangProcess.error;
    }


    if (clangProcess.stderr && clangProcess.stderr.length > 0) {
        log.warn(`clang++ stderr:\n${clangProcess.stderr}`);
    }
    if (!clangProcess.stdout || clangProcess.stdout.trim().length === 0) {
        throw new Error(`clang++ produced no output (stdout). AST generation failed. Error: ${clangProcess.stderr}`);
    }

    let astText = clangProcess.stdout;
    if (!astText.trim().startsWith('[')) {
        astText = '[' + astText.trim().replace(/}\s*{/g, '},{') + ']';
    }

    let astArr: ClangASTD[];
    try {
        astArr = JSON.parse(astText) as ClangASTD[];
    } catch (e) {
        log.error("Failed to parse AST JSON:", e);
        log.error("Problematic AST JSON content (first 1000 chars):", astText.substring(0, 1000));
        throw new Error(`Failed to parse AST JSON from clang++. Check for errors in C++ code or clang++ execution.`);
    }

    if (!astArr || astArr.length === 0) {
        log.warn(`No AST data was parsed. This might mean the ast-dump-filter ("${nameFilter.slice(0, -2)}") didn't match anything, or the input file is empty or has no relevant declarations.`);
    }


    const { cppBinding, tsDefinitions } = processAstAndGenerateCode(astArr, absoluteCppFilePath, nameFilter, additionalTypes, tsModuleName);

    if (!existsSync(absoluteOutputDir)) {
        try {
            mkdirSync(absoluteOutputDir, { recursive: true });
        } catch (e: any) {
            throw new Error(`Failed to create output directory ${absoluteOutputDir}: ${e.message}`);
        }
    }

    writeFileSync(join(absoluteOutputDir, cppBindingOutputFile), cppBinding);
    writeFileSync(join(absoluteOutputDir, tsDefinitionOutputFile), tsDefinitions);

    log(`Bindings generated successfully in ${absoluteOutputDir}`);
}